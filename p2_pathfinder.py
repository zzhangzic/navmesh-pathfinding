#Name Zijie Zhang#ID 1402410 zzhang40#Description: I do not know the partner needs to be different everytime we do an assignment, and it is too late for me to find a new partner, so I worked on this alone.from math import inf, sqrtfrom heapq import heappop, heappushdef find_path(source_point, destination_point, mesh):	try:		#finding the where source_point and destination_point lie in which box		source_box = findwhichbox(source_point,mesh)		destination_box = findwhichbox(destination_point,mesh)		#if they lie in the same box, return directly		if source_box == destination_box:			return([source_point,destination_point],[destination_box])		#all the neccesary set up		distance = {}		distance[source_box] = 0				previous = {}		queue = {}		path = []		detailpoints = {}				empty = {}		empty2 = {}				found = False		previous[source_box] = None				#enqueue cost, box, and point		queue = [(0,source_box,source_point)]				#while length of the queue >0		while len(queue)>0:			#popping from the queue			current_distance,current_box,current_point = heappop(queue)			#if the destination found			if check(destination_point, current_box) == True:				found = True				break			#checking nearby boxes and properties			for nearby_boxes in mesh['adj'][current_box]:				temp1 = detailpoint(current_point,current_box,nearby_boxes)				temp2 = coordistance(current_point,temp1)				cost = current_distance +temp2								if nearby_boxes not in previous or cost < distance[nearby_boxes]:					distance[nearby_boxes] = cost					ppts = cost + heuristic(destination_point,temp1)					previous[nearby_boxes] = current_box					heappush(queue, (ppts, nearby_boxes,temp1))		#if found				if found:			while current_box != source_box:				path.append(current_box)				current_box = previous[current_box]			path = path[::-1]			for anybox in path:				detailpoints[anybox] = (source_point,detailpoint(source_point,current_box, anybox))				if anybox != destination_box:						source_point = (detailpoint(source_point,current_box,anybox))				detailpoints[destination_box] = (source_point, destination_point)			return detailpoints.values(), previous.keys()	#exception	except:		return empty.values(), empty2.keys()		print('Failed to find path')	return None	passdef coordistance(source,destination): #function to calculate two points distance	ax = source[0]	ay = source[1]	bx = destination[0]	by = destination[1]	result = sqrt(((ax-bx)**2)+((ay-by)**2))	return result	passdef heuristic(source,destination): #function to calculate heuristic distance	ax = source[0]	ay = source[1]	bx = destination[0]	by = destination[1]	return (abs(ax-bx)+abs(ay-by))	pass	def detailpoint(point,sourcebox,destinationbox): #function to calculate to coordinate of detail point	sourcex = point[0]	sourcey = point[1]	# b1x1 = sourcebox[0]	# b1x2 = sourcebox[1]	# b1y1 = sourcebox[2]	# b1y2 = sourcebox[3]	ax1 = destinationbox[0]	ax2 = destinationbox[1]	by1 = destinationbox[2]	by2 = destinationbox[3]	newx = min(ax2,max(sourcex,ax1))	newy = min(by2,max(sourcey,by1))	return(newx,newy)	pass	def findwhichbox(source_point,mesh): #function to calculate point lies in which box	for box in mesh['boxes']:		if check(source_point,box) == True:			return box	pass	def check(point,box): #function to check if the point lie in this box	pointx = point[0]	pointy = point[1]	x1, x2, y1, y2 = box	if x1 <= pointx <= x2 and y1 <= pointy <= y2:		return True	else:		return False	pass						